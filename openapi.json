{
  "openapi": "3.0.2",
  "info": {
    "title": "ИНСТРУКЦИЯ ПО НАСТРОЙКЕ СКРИПТА ИНТЕГРАЦИИ ДЛЯ ПРИЕМА ПЛАТЕЖЕЙ",
    "version": "1.0",
    "x-logo": {
      "url": "/kassa/dev/assets/img/logo.svg"
    },
    "description": "# История изменений\n| **Описание изменений** | **Дата** |\n| ------ | -------- |\n| Создан документ | 23.04.2025 |\n\n\n# Введение\nIntegration.js — это способ интеграции методов оплат в приложения мерчанта.\n\nСкрипт позволяет добавить на сайт виджет с кнопками оплаты и открывать платежную форму в iframe, модальном или отдельном окнах.\n\n# Требования к подключению\nЧтобы использовать скрипты интеграции для виджета должны быть выполнены следующие требования:\n\n1. Cайт должен работать по протоколу HTTPS.\n2. На сайте должны отсутствовать заголовки:\n   ```\n   Cross-Origin-Opener-Policy: *\n   ```\n3. Политики CSP на сайте должны разрешать использовать:\n   ```\n   script-src: https://*.tinkoff.ru https://*.tcsbank.ru https://*.tbank.ru https://*.nspk.ru https://*.t-static.ru\n   frame-src: https://*.tinkoff.ru https://*.tcsbank.ru https://*.tbank.ru https://*.nspk.ru https://*.t-static.ru\n   img-src: https://*.tinkoff.ru https://*.tcsbank.ru https://*.tbank.ru https://*.nspk.ru https://*.t-static.ru\n   connect-src: https://*.tinkoff.ru https://*.tcsbank.ru https://*.tbank.ru https://*.nspk.ru https://*.t-static.ru\n   style-src: 'unsafe-inline' https://*.tinkoff.ru https://*.tcsbank.ru https://*.tbank.ru https://*.nspk.ru https://*.t-static.ru\n   ```\n\n# Поддерживаемые версии браузеров\n* Chrome >= 63;\n* Edge >= 19;\n* Safari >= 11;\n* Firefox >= 67;\n* Opera >= 50;\n* IE - не поддерживается;\n* Samsung Internet >= 8.2;\n* Opera Mobile >= 73.\n\n# Подготовка к использованию\nПосле подключения интернет-эквайринга зайдите в личный кабинет и выберите раздел «Магазины». Во вкладке «Терминалы» будет указан публичный ключ терминала — TerminalKey.\n\n[![Где найти номер терминал в ЛК](https://cdn.tbank.ru/static/documents/terminal_key_pf.png)](https://cdn.tbank.ru/static/documents/terminal_key_pf.png)\n\nЧтобы настроить терминал, нужно выбрать тип подключения «Универсальный» и на вкладке «Способы оплаты» включить нужные способы оплаты.\n\nЕсли вы подключаете платежную форму от Т-Банка:\n1. Зайдите в личный кабинет интернет эквайринга → «Магазины».\n2. Выберите ваш магазин → «Способы оплаты» → Выберите нужный способ оплаты → «Платежная форма Т-Банка» → «Включить».\n\nЕсли вы хотите настроить отдельную кнопку быстрой оплаты с помощью виджета:\n1. Зайдите в личный кабинет интернет эквайринга → «Магазины».\n2. Выберите ваш магазин → «Способы оплаты» → Выберите нужный способ оплаты → «Настроить» → «Своя платежная форма» → «Включить».\n\n# Подключение скрипта интеграции\n> Скрипт размещен по адресу https://acq-paymentform-integrationjs.t-static.ru/integration.js\nПолностью копировать скрипт в свою сборку не нужно. Рекомендуем всегда загружать скрипт из предоставленного URL. \nЭто позволит всегда использовать актуальную версию скрипта, включая все исправления и обновления безопасности.\n\n\n1. Установите HTML-код на всех нужных страницах перед закрывающим тегом </body>. \nПередайте в атрибут `onload` название метода, который будет отвечать за инициализацию и обработку платежей:\n\n```\n<script src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\" onload=\"onPaymentIntegrationLoad()\" async></script>\n```\n\nПроведите инициализацию скрипта:\n\n```\n<script>\n  const initConfig = { // IntegrationInitConfig интерфейс, описан в разделе \"Интерфейс глобальной конфигурации\"\n    ...\n  }    \n  \n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig).then().catch();\n  }\n</script>\n```\n\n<details><summary><b>Альтернативные способы инициализации</b></summary>\nМожно использовать любой из способов подключения: \n\n<details><summary><b>Простой</b></summary>\n\n```\n<script src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\" onload=\"onPaymentIntegrationLoad()\" async></script>\n<script>\n  const initConfig = { // IntegrationInitConfig интерфейс, описан в разделе \"Интерфейс глобальной конфигурации\"\n    ...\n  }\n  \n  function onPaymentIntegrationLoad() {\n     PaymentIntegration.init(initConfig)\n       .then(async (integration) => {\n         // Место для кода взаимодействия с объектом integration\n       }\n     ).catch();\n  }\n</script>\n```\n\n</details>\n\n<details><summary><b>Синхронный</b></summary>\n\n```\n<script src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\"></script>\n<script>\n  async function initPayment() {\n    const integration = await PaymentIntegration.init(initConfig); // initConfig - экземпляр интерфейса IntegrationInitConfig, описан в разделе \"Интерфейс глобальной конфигурации\"\n    // Место для кода взаимодействия с объектом integration\n  }\n \n  initPayment().then().catch();\n</script>\n```\n\n</details>\n\n<details><summary><b>Динамический</b></summary>\n\n```\n<script>\n  async function loadJs(url) {\n    return new Promise((resolve, reject) => {\n      const element = document.createElement('script');\n \n      element.src = url;\n      element.type = 'text/javascript';\n      element.async = true;\n      element.onload = () => resolve();\n      element.onerror = () => reject();\n      document.body.appendChild(element);\n    });\n  }\n \n  async function initPayment() {\n    await loadJs('https://acq-paymentform-integrationjs.t-static.ru/integration.js');\n \n    const integration = await PaymentIntegration.init(initConfig); // initConfig - экземпляр интерфейса IntegrationInitConfig, описан в разделе \"Интерфейс глобальной конфигурации\"\n    //  Место для кода взаимодействия с объектом integration\n  }\n \n  initPayment().then().catch();\n</script>\n```\n\n</details>\n\n</details>\n\n2. Настройте нужную конфигурацию скрипта.\nИспользуйте только те ключи объекта features (модули), которые вам нужны:\n\n```\n<script> \n  const initConfig = {\n    terminalKey: 'myTerminalKey', // <-- Значение terminalKey из личного кабинета\n    product: 'eacq',\n    features: {\n       payment: {}, // <-- Добавьте, если нужны кнопки оплаты\n       iframe: {} // <-- Добавьте, если нужно встроить платежную форму в iframe\n       addcardIframe: {} // <-- Добавьте, если нужно встроить приложение привязки карты в iframe\n    }\n  }\n</script>\n```\n\n<details><summary><b>Интерфейс глобальной конфигурации</b></summary>\n\n```\nexport interface IntegrationInitConfig {\n  /**\n   * Значение terminalKey из личного кабинета\n   */\n  terminalKey: string;\n  /**\n   * Продукт, для интернет-эквайринга значение 'eacq'\n   */\n  product: 'eacq';\n  features:  {   \n    /**\n    * При включении iframe ключа в конфигурацию будет загружен модуль работы с iframe для приложения привязки карты\n    */\n    addcardIframe?: {\n      /**\n       * Если используется параметр container, скрипт встроит iframe в этот элемент\n       * На странице должен существовать элемент с id=\"paymentContainer\"\n       */\n      container?: HTMLElement | null;\n      /**\n       * Возможность переопределить стандартное поведение виджета\n       */\n      config?: IframeIntegrationConfig; // Интерфейс описан в разделе \"Конфигурация IframeIntegrationConfig\" \n      /**\n       * Функция paymentStartCallback должна возвращать Promise который резолвит ссылку PaymentUrl (ссылка платежной формы)\n       *\n       * В этой функции должен происходить вызов вашего backend-сервиса с передачей туда внутреннего orderId\n       * backend-сервис находит необходимые для запроса метода \"Инициировать платеж\" поля (такие как сумма) внутри вашей системы и отправляет запрос в v2/Init\n       * PaymentUrl из v2/Init должен быть возвращен во frontend в paymentStartCallback\n       *\n       * Например:\n       * const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n       * return res.PaymentURL;\n       *\n       * Переменная PaymentIntegration содержит класс-помощник Helpers c методом request для отправки запросов на бекенд\n       * В данном примере URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n       *\n       * @param {OverlayType} paymentType - способ оплаты выбранный пользователем\n       * @returns {Promise<string>}\n       */      \n      paymentStartCallback?: PaymentStartCallback;\n    };\n    /**\n     * При включении iframe ключа в конфигурацию будет загружен модуль работы с iframe\n     */\n    iframe?: {\n      /**\n       * Если используется параметр container, скрипт встроит iframe в этот элемент\n       * На странице должен существовать элемент с id=\"paymentContainer\"\n       */\n      container?: HTMLElement | null;\n      /**\n       * Возможность переопределить стандартное поведение виджета\n       */\n      config?: IframeIntegrationConfig; // Интерфейс описан в разделе \"Конфигурация IframeIntegrationConfig\"\n      /**\n       * Функция paymentStartCallback должна возвращать Promise который резолвит ссылку PaymentUrl (ссылка платежной формы)\n       *\n       * В этой функции должен происходить вызов вашего backend-сервиса с передачей туда внутреннего orderId\n       * backend-сервис находит необходимые для запроса метода \"Инициировать платеж\" поля (такие как сумма) внутри вашей системы и отправляет запрос в v2/Init\n       * `PaymentUrl` из v2/Init должен быть возвращен во frontend в paymentStartCallback\n       *\n       * Например:\n       * const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n       * return res.PaymentURL;\n       *\n       * Переменная PaymentIntegration содержит класс-помощник Helpers c методом request для отправки запросов на backend\n       * В данном примере URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n       *\n       * @param {OverlayType} paymentType - способ оплаты выбранный пользователем\n       * @returns {Promise<string>}\n       */           \n      paymentStartCallback?: PaymentStartCallback;\n    };\n    /**\n     * При включении payment ключа в конфигурацию будет загружен модуль работы с виджетами оплаты\n     */\n    payment?: {\n      /**\n       * Если используется параметр container, скрипт встроит все доступные терминалу методы оплаты в этот элемент\n       * На странице должен существовать элемент с id=\"paymentContainer\"\n       */\n      container?: HTMLElement | null;\n      /**\n       * Возможность переопределить стандартное поведение виджета\n       */\n      config?: PaymentIntegrationConfig; // Интерфейс описан в разделе \"Конфигурация PaymentIntegrationConfig\"\n      /**\n       * Функция paymentStartCallback должна возвращать Promise который резолвит ссылку PaymentUrl (ссылка платежной формы)\n       *\n       * В этой функции должен происходить вызов вашего backend-сервиса с передачей туда внутреннего orderId\n       * backend-сервис находит необходимые для запроса метода \"Инициировать платеж\" поля (такие как сумма) внутри вашей системы и отправляет запрос в v2/Init\n       * PaymentUrl из v2/Init должен быть возвращен во frontend в paymentStartCallback\n       *\n       * Например:\n       * const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n       * return res.PaymentURL;\n       *\n       * Переменная PaymentIntegration содержит класс-помощник Helpers c методом request для отправки запросов на backend\n       * В данном примере URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n       *\n       * @param {OverlayType} paymentType - способ оплаты выбранный пользователем\n       * @returns {Promise<string>}\n       */  \n      paymentStartCallback?: PaymentStartCallback;\n    };\n  };\n}\n```\n\n</details>\n\n<details><summary><b>Пример конфигурации для кнопок оплаты</b></summary>\n\n```\n<script>\n  const initConfig = {\n    /**\n     * Значение terminalKey из личного кабинета\n     */\n    terminalKey: 'myTerminalKey',\n    product: 'eacq',\n    features: {\n      payment: {\n        /**\n         * Если используется параметр container, скрипт встроит все доступные терминалу методы оплаты в этот элемент\n         * На странице должен существовать элемент с id=\"paymentContainer\"\n         */\n        container: document.getElementById('paymentContainer'),\n        /**\n         * Функция paymentStartCallback должна возвращать Promise который резолвит ссылку PaymentUrl (ссылка платежной формы)\n         *\n         * В этой функции должен происходить вызов вашего backend-сервиса с передачей туда внутреннего orderId\n         * backend-сервис находит необходимые для запроса метода \"Инициировать платеж\" поля (такие как сумма) внутри вашей системы и отправляет запрос в v2/Init\n         * PaymentUrl из v2/Init должен быть возвращен во frontend в paymentStartCallback\n         *\n         * Например:\n         * const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n         * return res.PaymentURL;\n         *\n         * Переменная PaymentIntegration содержит класс-помощник Helpers c методом request для отправки запросов на бекенд\n         * В данном примере URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n         *\n         * @param {OverlayType} paymentType - способ оплаты выбранный пользователем\n         * @returns {Promise<string>}\n         */\n        paymentStartCallback: async () => {\n          const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS); // <-- URL это url вашего backend, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге\n          return res.PaymentURL;\n        },\n      },\n    },\n  };\n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig).then().catch();\n  }\n</script>\n```\n\n</details>\n\n<details><summary><b>Пример конфигурации для платежной формы в iframe</b></summary>\n\n```\n<script> \n  const initConfig = {\n    terminalKey: 'myTerminalKey', // <-- Значение terminalKey из личного кабинета\n    product: 'eacq',\n    features: {\n       iframe: { // <-- Добавьте, если нужно встроить платежную форму в iframe\n          container: document.getElementById('paymentContainer'), // <-- На странице должен существовать элемент с id=\"paymentContainer\"\n          paymentStartCallback: async () => {     \n            const res = await integration.helpers.init(URL, 'POST', {}); // <-- URL это url вашего backend, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге\n            return res.paymentUrl;\n          }        \n       }\n    }\n  }\n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig).then().catch();\n  }\n</script>\n```\n\n</details>\n\n# Модули\n\n## Кнопки быстрой оплаты\n\nПоддерживаемые виджеты оплаты (WidgetType):\n* sbp — кнопка оплаты через СБП;\n* tpay — кнопка оплаты через T-Pay;\n* bnpl — кнопка оплаты Долями;\n* sberpay — кнопка оплаты через SberPay. Не отображается в WebView;\n* mirpay — кнопка оплаты через MirPay. Отображается только для устройств на ОС Android.\n\nЕсть два способа интеграции виджета:\n\n* Все доступные методы оплаты — добавляет все включенные в личном кабинете способы оплаты в указанный контейнер (в примере paymentContainer);\n* Ручной — позволяет добавлять разные методы оплаты в разные контейнеры.\n\nОба способа поддерживают установку и переопределение конфигураций.\n\n<details><summary><b>Все доступные методы оплаты</b></summary>\n\n<details><summary><b>Из глобальной конфигурации</b></summary>\nИспользуйте скрипт из глобальной конфигурации:\n\n```\n<script> \n  const initConfig = {\n    terminalKey: 'myTerminalKey', // <-- Значение terminalKey из личного кабинета\n    product: 'eacq',\n    features: {\n       payment: { // <-- Добавляем, если нужны кнопки оплаты\n          container: document.getElementById('paymentContainer'), // <-- На странице должен существовать элемент с id=\"paymentContainer\"\n          paymentStartCallback: async (paymentType) => { // <-- paymentType может использоваться для сбора аналитики         \n            const res = await integration.helpers.init(URL, 'POST', {}); // <-- URL это url вашего backend, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге\n            return res.paymentUrl;\n          },\n          config: {} // <-- Возможность переопределить поведение виджета (интерфейс PaymentIntegrationConfig,  описан в разделе \"Конфигурация PaymentIntegrationConfig\")\n       }\n    }\n  }\n</script>\n```\n\n</details>\n\n<details><summary><b>Динамически</b></summary>\n\n1. Используйте скрипт из глобальной конфигурации:\n\n```\n<script> \n  const initConfig = {\n    terminalKey: 'myTerminalKey', // <-- Значение terminalKey из личного кабинета\n    product: 'eacq',\n    features: {\n       payment: {}\n    }\n  }\n</script>\n```\n\n2. Создайте и соберите скрипт платежной интеграции со всеми возможными способами оплат:\n\n```\nconst container = document.getElementById('paymentContainer'); // Получите элемент, в который хотите встроить виджет\nconst MAIN_INTEGRATION_CONFIG = {}; // Конфигурация описана в разделе \"Конфигурация PaymentIntegrationConfig\"\nconst mainPaymentIntegration = await integration.payments.mountAllAvailable(container, MAIN_INTEGRATION_CONFIG); // Создание интеграции\n```\n\n</details>\n\n</details>\n\n<details><summary><b>Ручной</b></summary>\n\n1. Используйте скрипт из глобальной конфигурации:\n\n```\n<script> \n  const initConfig = {\n    terminalKey: 'myTerminalKey', // <-- Значение terminalKey из личного кабинета\n    product: 'eacq',\n    features: {\n       payment: {}\n    }\n  }\n</script>\n```\n\n2. Создайте экземпляр платежной интеграции (блок с кнопками оплаты):\n\n```\nconst MAIN_INTEGRATION_NAME = 'main-integration-name'; // Любое название для идентификации конкретной интеграции\nconst MAIN_INTEGRATION_CONFIG = {}; // Конфигурация описана в разделе \"Конфигурация PaymentIntegrationConfig\"\nconst mainPaymentIntegration = await integration.payments.create(MAIN_INTEGRATION_NAME, MAIN_INTEGRATION_CONFIG); // Создание интеграции\n```\n\nНа этом этапе создается объект интеграции кнопок оплаты, сами способы оплаты не отображаются. Интеграция не привязана ни к какому контейнеру.\nТакой подход позволяет использовать несколько разных интеграций со своими методами оплаты одновременно.\n\n<details><summary><b>Получение объекта платежной интеграции после смены контекста выполнения</b></summary>\n\n```\nconst mainPaymentIntegration = await integration.payments.get('main-integration-name'); // Получение интеграции\n```\n\n</details>\n\n3. Смонтируйте интеграцию:\n\n```\nconst container = document.getElementById('paymentContainer'); // Получите элемент, в который хотите встроить виджет\nawait mainPaymentIntegration.mount(container); // Монтируем интеграцию в контейнер\n```\n\n4. Отобразите кнопки платежных методов.\nНа этом этапе определяется, какие методы оплаты будут отображены в контейнере. Предварительно следует включить нужные методы оплаты в личном кабинете:\n\n```\nconst widgetTypes = ['tpay']; // Доступные методы оплаты указаны в начале раздела \"Кнопки быстрой оплаты\"\nawait mainPaymentIntegration.updateWidgetTypes(widgetTypes); // Передаем нужные методы оплаты в интеграцию\n```\n\n>Скрипт определяет, включены ли способы оплаты в личном кабинете:\n>* если нужные способы оплаты отключены в личном кабинете — измените updateWidgetTypes;\n>* если способ оплаты отключен в личном кабинете, но не выключен в скрипте — способ оплаты будет пропущен.\n\n5. Установка PaymentStartCallback.\nПереданная callback-функция срабатывает каждый раз, когда пользователь нажимает кнопку оплаты на платежной форме.\nПри нажатии подразумевается вызов метода [Инициировать платеж](https://www.tbank.ru/kassa/dev/payments/#tag/Standartnyj-platezh/operation/Init).\nФункция требует возврата string с `PaymentUrl` (например https://securepayments.tinkoff.ru/uuid). \n\n```\n<script>\n  const initConfig = { // IntegrationInitConfig интерфейс, описан в разделе \"Интерфейс глобальной конфигурации\"\n    ...\n  }\n  \n  function onPaymentIntegrationLoad() {\n     PaymentIntegration.init(initConfig)\n       .then(async (integration) => {\n  \n         /*\n           Переданный callback сработает каждый раз при нажатии на кнопку оплаты\n         */\n         await integration.payments.setPaymentStartCallback(async () => {              \n           /**\n            * Функция paymentStartCallback должна возвращать Promise который резолвит ссылку PaymentUrl (ссылка платежной формы)\n            *\n            * В этой функции должен происходить вызов вашего backend-сервиса с передачей туда внутреннего orderId\n            * backend-сервис находит необходимые для запроса метода \"Инициировать платеж\" поля (такие как сумма) внутри вашей системы и отправляет запрос в v2/Init\n            * PaymentUrl из v2/Init должен быть возвращен во frontend в paymentStartCallback\n            *\n            * Например:\n            * const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n            * return res.PaymentURL;\n            *\n            * Переменная PaymentIntegration содержит класс-помощник Helpers c методом request для отправки запросов на backend\n            * В данном примере URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n            *\n            * @param {OverlayType} paymentType - способ оплаты выбранный пользователем\n            * @returns {Promise<string>}\n            */\n           const res = await integration.helpers.init(URL, 'POST', {}); // <-- URL это url вашего backend, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге\n   \n           return res.paymentUrl;\n         });\n       }\n     ).catch();\n  }\n</script>\n```\n\n>Особенности использования метода [Инициировать платеж](https://www.tbank.ru/kassa/dev/payments/#tag/Standartnyj-platezh/operation/Init):\n>* Не используйте вызов метода с передачей суммы в теле запроса из frontend-приложения. Всегда используйте свой backend-сервис. Если backend-сервиса нет, рекомендуем использовать наш [Конструктор сайтов](https://www.tbank.ru/business/website-builder/).\n>* Обязательно передавайте `connection_type` = `Widget` в объекте DATA. В ином случае корректная работа виджета не гарантирована.\n\n</details>\n\nОба способа поддерживают настройку виджета:\n\n1. Получите объект платежной интеграции:\n\n```\nconst mainPaymentIntegration = await integration.payments.get('main-integration'); // Получение интеграции. При интеграции \"Все доступные способы оплаты\" присваивается имя \"main-integration\"\n```\n\n2. Используйте нужные методы для передачи настроек:\n\n<details><summary><b>Настройка отображения кнопок платежных методов</b></summary>\n\n```\nconst displayParams = {\n  gap: 0.375, // Расстояние между кнопками в rem\n  hight: 3.5, // Высота кнопки в rem\n  radius: 0.75, // Закругление кнопки в rem\n  theme: {\n    default: 'accent',\n  }\n}\nawait mainPaymentIntegration.updateDisplayParams(displayParams); // Передаем нужные методы оплаты в инстанс интеграции\n\n```\n<details><summary><b>Интерфейс метода displayParams</b></summary>\n\n```\nexport interface WidgetDisplayParams {\n  gap?: number;\n  height?: number;\n  radius?: number;\n  theme?: {\n    default?: ButtonTheme;\n    tpay?: ButtonThemeTpay;\n    mirpay?: ButtonTheme;\n    sbp?: ButtonTheme;\n    bnpl?: ButtonTheme;\n    sberpay?: ButtonTheme;\n  };\n}\n \nexport type ButtonTheme = 'accent' | 'filled' | 'outlined';\nexport type ButtonThemeTpay = 'accent' | 'accent-black' | 'filled' | 'outlined';\n```\n\n</details>\n\n</details>\n\n<details><summary><b>Смена языка</b></summary>\n\n```\nawait mainPaymentIntegration.setLang(LANG) // LANG = 'ru' | 'en'\n```\n\n</details>\n\n<details><summary><b>Смена темы</b></summary>\n\nЕсли метод setTheme не вызван, тема будет изменяться автоматически в соответствии с системной\n\n```\nawait mainPaymentIntegration.setTheme(THEME) // THEME = 'dark' | 'light'\n```\n\n</details>\n\n<details><summary><b>Блокировка и разблокировка кнопок</b></summary>\n\nБлокирует кнопки\n\n```\nawait mainPaymentIntegration.lock()\n```\nРазблокирует кнопки\n\n```\nawait mainPaymentIntegration.unlock()\n```\n\n</details>\n\n<details><summary><b>Удаление интеграции</b></summary>\n\n```\nawait integration.payment.remove(MAIN_INTEGRATION_NAME)\n// или\nawait mainPaymentIntegration.unmount()\n```\n\n</details>\n\n### Конфигурация PaymentIntegrationConfig\n<details><summary><b>Интерфейс конфигурации PaymentIntegrationConfig</b></summary>\n\n```\nexport interface PaymentIntegrationConfig {\n  /**\n   * Срабатывает после загрузки кнопок оплаты (перед отображением)\n   * Может быть использован для отображения loader в контейнере\n   */\n  loadedCallback?: () => void;\n  /**\n   * Возможность переопределить значение z-index оверлея\n   */\n  zIndex?: number;\n  scroll?: {\n    /**\n     * Основной элемент страницы с включенным overflow\n     * Используется для блокировки скролла во время отображения оверлея\n     * По умолчанию - document.body\n     */\n    elementForBlocking?: HTMLElement;\n  };\n  router?: {\n    /**\n     * Вызывается в момент получения события на открытие deepLink\n     * Стандартное значение: (url) => {window.location.href = url}\n     * @param url\n     */\n    deepLinkRedirectCallback?: (url: string) => Promise<void>;\n    /**\n     * Вызывается в момент получения события на открытие массива deepLink.\n     * Требуется для перебора разных приложений, например, для sberpay\n     * Стандартное значение: (links) => {\n     *   window.open(\n     *       `URL?links=${encodeURIComponent(JSON.stringify(links))}`,\n     *       '_blank',\n     *     );\n     * }\n     * URL - url скрипта перебора deepLink\n     * @param url\n     */\n    deepLinksRedirectCallback?: (links: string[]) => Promise<void>;\n    /**\n     * Вызывается в момент получения события на редирект\n     * Стандартное значение: (url) => {window.location.href = url}\n     * @param url\n     */\n    redirectCallback?: (url: string) => Promise<void>;\n  };    \n \n  dialog?: {\n    /**\n     * Вызывается в момент получения события exit (оплата отменена пользователем)\n     * Например, при нажатии кнопки «Вернуться в магазин» или закрытии модального окна\n     * @param url\n     */\n    closedCallback?: () => Promise<void>;\n  };\n \n  status?: {\n    /**\n     * Флаг открытия overlay при смене статуса\n     * Если в процессе оплаты диалог оплаты был закрыт, но произошла смена статуса\n     * При значении true флага, откроется диалог и отобразится статус платежа\n     * Стандартное значение: true\n     */\n    openOverlay?: boolean;\n    /**\n     * Вызывается в момент изменения статуса платежа\n     * @param status\n     */\n    changedCallback?: (status: PaymentIntegrationStatus) => Promise<void>;\n  };\n \n  payment?: {\n    /**\n     * Вызывается в момент получения ошибки в paymentStartCallback во время инициализации платежа\n     */\n    failedPaymentStartCallback?: (error: Error) => Promise<void>;\n  };\n \n  alert?: {\n    /**\n     * Используется для показа алертов при ошибках\n     * При отсутствии используются стандартные алерты\n     * @param alert\n     */\n    showAlertCallback?: (alert: AlertInfo) => Promise<void>;\n  };\n }\n```\n\n```\nexport type PaymentIntegrationStatus =\n  | 'CANCELED'\n  | 'EXPIRED'\n  | 'NEW'\n  | 'PROCESSING_ERROR'\n  | 'PROCESSING'\n  | 'REFUNDED'\n  | 'REJECTED'\n  | 'SUCCESS';\n```\n\n</details>\n\n## Открытие платежной формы в iframe\nЕсть два способа открытия в iframe:\n\n<details><summary><b>Из глобальной конфигурации</b></summary>\nИспользуйте скрипт из глобальной конфигурации:\n\n```\n<script>    \n  const initConfig = {\n    /**\n     * Значение terminalKey из личного кабинета\n     */\n    terminalKey: 'myTerminalKey',\n    product: 'eacq',\n    features: {\n      iframe: {\n        /**\n         * Если используется параметр container, скрипт встроит iframe в этот элемент\n         * На странице должен существовать элемент с id=\"paymentContainer\"\n         */\n        container: document.getElementById('paymentContainer'),         \n        /**\n         * Функция paymentStartCallback должна возвращать Promise который резолвит ссылку PaymentUrl (ссылка платежной формы)\n         *\n         * В этой функции должен происходить вызов вашего backend-сервиса с передачей туда внутреннего orderId\n         * backend-сервис находит необходимые для запроса метода \"Инициировать платеж\" поля (такие как сумма) внутри вашей системы и отправляет запрос в v2/Init\n         * PaymentUrl из v2/Init должен быть возвращен во frontend в paymentStartCallback\n         *\n         * Например:\n         * const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n         * return res.PaymentURL;\n         *\n         * Переменная PaymentIntegration содержит класс-помощник Helpers c методом request для отправки запросов на backend\n         * В данном примере URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n         *\n         * @param {OverlayType} paymentType - способ оплаты, выбранный пользователем\n         * @returns {Promise<string>}\n         */\n        paymentStartCallback: async () => {\n          const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n          return res.PaymentURL;\n        },\n      },\n    },\n  };\n  \n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig).then().catch();\n  }\n</script>\n```\n\n</details>\n\n<details><summary><b>Динамически</b></summary>\n\n1. Используйте скрипт из глобальной конфигурации:\n\n```\n<script> \n  const initConfig = {\n    terminalKey: 'myTerminalKey', // <-- Значение terminalKey из личного кабинета\n    product: 'eacq',\n    features: {\n       iframe: {}\n    }\n  }\n</script>\n```\n\n2. Создайте экземпляр iframe интеграции:\n\n```\nconst MAIN_INTEGRATION_NAME = 'main-integration-name'; // Любое название для идентификации конкретной интеграции\nconst iframeConfig = {}; // Конфигурация описана разделе \"Конфигурация IframeIntegrationConfig\"\nconst mainPaymentIntegration = await integration.iframe.create(MAIN_INTEGRATION_NAME, iframeConfig); // Создание интеграции\n```\n\nНа этом этапе создается объект интеграции iframe, форма оплаты отражена не будет. Интеграция не привязана ни к какому контейнеру.\nТакой подход позволяет использовать несколько разных интеграций одновременно.\n\n3. Смонтируйте интеграцию:\n\n```\nconst container = document.getElementById('paymentContainer'); // Получаем элемент, в который хотите встроить платежную форму\nconst res = await integration.helpers.init(URL,'POST', INIT_PARAMS) // Инициируем платеж или получение paymentUrl из вашего backend-сервиса\nawait mainPaymentIntegration.mount(container, res.paymentUrl); // Монтируем интеграцию в контейнер\n```\n>Особенности использования метода [Инициировать платеж](https://www.tbank.ru/kassa/dev/payments/#tag/Standartnyj-platezh/operation/Init):\n>* Не используйте вызов метода с передачей суммы в теле запроса из frontend-приложения. Всегда используйте свой backend-сервис. Если backend-сервиса нет, рекомендуем использовать наш [Конструктор сайтов](https://www.tbank.ru/business/website-builder/)\n\n</details>\n\nОба способа поддерживают настройку платежной формы в iframe:\n\n1. Получите объект iframe-интеграции:\n\n```\nconst mainPaymentIntegration = await integration.iframe.get('main-integration-name'); // Получение интеграции. При использовании метода \"Из глобальной конфигурации\" присваивается имя \"main-integration\"\n```\n\n2. Используйте необходимые методы для передачи настроек:\n\n<details><summary><b>Смена языка</b></summary>\n\n```\nawait mainPaymentIntegration.setLang(LANG) // LANG = 'ru' | 'en'\n```\n\n</details>\n\n<details><summary><b>Смена темы</b></summary>\n\nЕсли метод setTheme не вызван, тема будет изменяться автоматически в соответствии с системной\n\n```\nawait mainPaymentIntegration.setTheme(THEME) // THEME = 'dark' | 'light'\n```\n\n</details>\n\n<details><summary><b>Удаление интеграции</b></summary>\n\n```\nawait integration.iframe.remove(MAIN_INTEGRATION_NAME)\n// или\nawait mainPaymentIntegration.unmount()\n```\n\n</details>\n\n### Конфигурация IframeIntegrationConfig\n<details><summary><b>Интерфейс конфигурации IframeIntegrationConfig</b></summary>\n\n```\nexport interface IframeIntegrationConfig {\n  router?: {\n    /**\n     * Вызывается в момент получения события на открытие deepLink\n     * Стандартное значение: (url) => {window.location.href = url}\n     * @param url\n     */\n    deepLinkRedirectCallback?: (url: string) => Promise<void>;\n    /**\n     * Вызывается в момент получения события на открытие массива deepLink.\n     * Требуется для перебора разных приложений, например, для sberpay\n     * Стандартное значение: (links) => {\n     *   window.open(\n     *       `URL?links=${encodeURIComponent(JSON.stringify(links))}`,\n     *       '_blank',\n     *     );\n     * }\n     * URL - url скрипта перебора deepLink\n     * @param url\n     */\n    deepLinksRedirectCallback?: (links: string[]) => Promise<void>;\n    /**\n     * Вызывается в момент получения события на редирект\n     * Стандартное значение: (url) => {window.location.href = url}\n     * @param url\n     */\n    redirectCallback?: (url: string) => Promise<void>;\n  };\n  language?: {\n    /**\n     * Вызывается в момент изменения языка из платежной формы\n     * @param status\n     */\n    changedCallback?: (lang: IntegrationLang) => Promise<void>;\n  };\n  status?: {\n    /**\n     * Вызывается в момент изменения статуса платежа\n     * @param status\n     */\n    changedCallback?: (status: PaymentIntegrationStatus) => Promise<void>;\n  };\n}\n```\n\n```\nexport type PaymentIntegrationStatus =\n  | 'CANCELED'\n  | 'EXPIRED'\n  | 'NEW'\n  | 'PROCESSING_ERROR'\n  | 'PROCESSING'\n  | 'REFUNDED'\n  | 'REJECTED'\n  | 'SUCCESS';\n```\n\n</details>\n\n### Платежная форма во вложенном iframe\n<details><summary><b>Интеграция платежной формы во вложенном iframe</b></summary>\n\nБывают случаи, когда приложение используется внутри iframe, который находится внутри другого iframe.\nДля работы виджета, нужно встроить скрипт и инициализировать его во всех вложенных iframe:\n\n1. Встройте и инициализируйте скрипт в основную (родительскую страницу):\n\n```\n<iframe id=\"payment-form-iframe\"></iframe\n```\n\n```\n// Загрузка и инициализация скрипта (js код)\nawait mainPaymentIntegration.connect(document.getElementById('payment-form-iframe'))\n```\n\n2. Встройте и инициализируйте скрипт во вложенных iframe.\nВ конечном вложенном iframe, подключение виджета аналогично инструкции в разделе \"Открытие платежной формы в iframe\".\nКаждый «промежуточный» скрипт будет перенаправлять сообщения в следующий iframe.\n\n```\n<iframe id=\"payment-form-iframe\"></iframe>\n```\n\n```\n// Загрузка и инициализация скрипта (js rjl)\nawait innerPaymentIntegration.connect(document.getElementById('payment-form-iframe')) // Если iframe создан\n```\n\n</details>\n\n# Примеры полной конфигурации\n\n## Виджет с кнопками оплаты (integration.payments)\n\n<details><summary><b>Все доступные способы оплаты</b></summary>\n\n```\n<div id=\"paymentContainer\"></div>\n<script>\n  /**\n   * URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет эквайринге и вернет PaymentURL\n   * @type {string}\n   */\n  const URL = 'https://Init';\n  /**\n   * INIT_PARAMS - это необходимые параметры тела запроса, которые принимает ваш backend-сервис\n   * @type object\n   */\n  const INIT_PARAMS = {\n    get OrderId() {\n      return `${Date.now()}${Math.floor(Math.random() * 100)}`; // Случайное число, используется для примера\n    }\n  };\n</script>\n<script\n  async\n  onload=\"onPaymentIntegrationLoad()\"\n  src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\"\n></script>\n<script>\n  const initConfig = {\n    /**\n     * Значение terminalKey из личного кабинета\n     */\n    terminalKey: 'myTerminalKey',\n    product: 'eacq',\n    features: {\n      payment: {\n        container: document.getElementById('paymentContainer'),               \n        paymentStartCallback: async () => {\n          const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n          return res.PaymentURL;\n        },\n      },\n    },\n  };\n  \n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig).then().catch();\n  }\n</script>\n```\n</details>\n\n<details><summary><b>Ручной, с включенными tpay, sbp и mirpay</b></summary>\n\n```\n<div id=\"paymentContainer\"></div>\n<script>\n  /**\n   * URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n   * @type {string}\n   */\n  const URL = 'https://Init';\n  /**\n   * INIT_PARAMS - это необходимые параметры тела запроса, которые принимает ваш backend-сервис\n   * @type object\n   */\n  const INIT_PARAMS = {\n    get OrderId() {\n      return `${Date.now()}${Math.floor(Math.random() * 100)}`; // Случайное число, используется для примера\n    }\n  };\n</script>\n<script\n  async\n  onload=\"onPaymentIntegrationLoad()\"\n  src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\"\n></script>\n<script>\n  const initConfig = {\n    /**\n     * Значение terminalKey из личного кабинета\n     */\n    terminalKey: 'myTerminalKey',\n    product: 'eacq',\n    features: {\n      payment: {},\n    },\n  };\n  \n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig)\n      .then(async (integration) => {\n        const MAIN_INTEGRATION_NAME = 'main-integration-name'; // Любое название для идентификации конкретной интеграции\n        const MAIN_INTEGRATION_CONFIG = {}; // Конфигурация описана в разделе \"Конфигурации PaymentIntegrationConfig\"\n        const mainPaymentIntegration = await integration.payments.create(\n          MAIN_INTEGRATION_NAME,\n          MAIN_INTEGRATION_CONFIG,\n        ); // Создание интеграции\n  \n        const container = document.getElementById('paymentContainer'); // Получите элемент, в который хотите встроить виджет\n        await mainPaymentIntegration.mount(container); // Монтируем интеграцию в контейнер\n  \n        await integration.payments.setPaymentStartCallback(async () => {\n          const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n  \n          return res.paymentUrl;\n        });\n  \n        const widgetTypes = ['mirpay', 'sbp', 'tpay']; // Доступные методы оплаты\n        await mainPaymentIntegration.updateWidgetTypes(widgetTypes); // Передаем нужные методы оплаты в интеграцию\n      })\n      .catch();\n  }\n</script>\n```\n\n</details>\n\n## Платежная форма в iframe\n\n<details><summary><b>Из глобальной конфигурации</b></summary>\n\n```\n<div id=\"paymentContainer\"></div>\n<script>\n  /**\n   * URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n   * @type {string}\n   */\n  const URL = 'https://Init';\n  /**\n   * INIT_PARAMS - это необходимые параметры тела запроса, которые принимает ваш backend-сервис\n   * @type object\n   */\n  const INIT_PARAMS = {\n    get OrderId() {\n      return `${Date.now()}${Math.floor(Math.random() * 100)}`; // Случайное число, используется для примера\n    }\n  };\n</script>\n<script\n  async\n  onload=\"onPaymentIntegrationLoad()\"\n  src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\"\n></script>\n<script>\n  const initConfig = {\n    /**\n     * Значение terminalKey из личного кабинета\n     */\n    terminalKey: 'myTerminalKey',\n    product: 'eacq',\n    features: {\n      iframe: {\n        container: document.getElementById('paymentContainer'),          \n        paymentStartCallback: async () => {\n          const res = await new PaymentIntegration.Helpers().request(URL, 'POST', INIT_PARAMS);\n          return res.PaymentURL;\n        },\n      },\n    },\n  };\n  \n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig).then().catch();\n  }\n</script>\n```\n\n</details>\n\n<details><summary><b>Динамически</b></summary>\n\n```\n<div id=\"paymentContainer\"></div>\n<script>\n  /**\n   * URL - это url вашего backend-сервиса, который вызовет метод \"Инициировать платеж\" в интернет-эквайринге и вернет PaymentURL\n   * @type {string}\n   */\n  const URL = 'https://Init';\n  /**\n   * INIT_PARAMS - это необходимые параметры тела запроса, которые принимает ваш backend-сервис\n   * @type object\n   */\n  const INIT_PARAMS = {\n    get OrderId() {\n      return `${Date.now()}${Math.floor(Math.random() * 100)}`; // Случайное число, используется для примера\n    },\n    TerminalKey: 'myTerminalKey',\n    Amount: 10000,\n    Description: 'test payment',\n  };\n</script>\n<script\n  async\n  onload=\"onPaymentIntegrationLoad()\"\n  src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\"\n></script>\n<script>\n  const initConfig = {\n    /**\n     * Значение terminalKey из личного кабинета\n     */\n    terminalKey: 'myTerminalKey',\n    product: 'eacq',\n    features: {\n      iframe: {}\n    },\n  };\n  \n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig)\n      .then(async (integration) => {\n        const MAIN_INTEGRATION_NAME = 'main-integration-name';\n        const iframeConfig = {};\n        const mainPaymentIntegration = await integration.iframe.create(MAIN_INTEGRATION_NAME, iframeConfig);\n  \n        const container = document.getElementById('paymentContainer');\n  \n        const res = await integration.helpers.init(URL, 'POST', INIT_PARAMS);\n  \n        await mainPaymentIntegration.mount(container, res.PaymentURL);\n      })\n      .catch();\n  }\n</script>\n```\n\n</details>\n\n<details><summary><b>Платежная форма во вложенном iframe</b></summary>\n\n1. Добавьте и инициализируйте скрипт на основном сайте:\n\n```\n<iframe id=\"first-iframe\" src=\"https://IFRAME_FIRST_URL\"></div>\n<script\n  async\n  onload=\"onPaymentIntegrationLoad()\"\n  src=\"https://acq-paymentform-integrationjs.t-static.ru/integration.js\"\n></script>\n<script>\n  const initConfig = {\n    /**\n     * Значение terminalKey из личного кабинета\n     */\n    terminalKey: 'myTerminalKey',\n    product: 'eacq',\n    features: {\n      iframe: {},\n    },\n  };\n  \n  function onPaymentIntegrationLoad() {\n    PaymentIntegration.init(initConfig)\n      .then(async (integration) => {\n        const MAIN_INTEGRATION_NAME = 'main-integration-name';\n        const iframeConfig = {};\n        const mainPaymentIntegration = await integration.iframe.create(MAIN_INTEGRATION_NAME, iframeConfig);\n  \n        const iframe = document.getElementById('first-iframe');\n  \n        await mainPaymentIntegration.connect(iframe);\n      })\n      .catch();\n  }\n</script>\n```\n\n2. Подключите для вложенного iframe скрипт по инструкции в разделе \"Открытие платежной формы в iframe\".\n\n</details>",
    "license": {
      "name": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  },
  "servers": [
    {
      "url": "https://rest-api-test.tinkoff.ru/v2",
      "description": "Тестовый URL. Для возможности отправки запросов с IP-адресов, которые находятся вне РФ, напишите на почту acq_help@tbank.ru c просьбой добавить ваши IP в WL"
    },
    {
      "url": "https://securepay.tinkoff.ru/v2",
      "description": "Боевой URL"
    }
  ],
  "paths": {},
  "components": {}
}